"use strict";(self.webpackChunkviolet_eco_github_io=self.webpackChunkviolet_eco_github_io||[]).push([[3848],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>v});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=l(n),h=o,v=p["".concat(s,".").concat(h)]||p[h]||u[h]||i;return n?r.createElement(v,a(a({ref:t},d),{},{components:n})):r.createElement(v,a({ref:t},d))}));function v(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[p]="string"==typeof e?e:o,a[1]=c;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8397:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const i={slug:"hardware",sidebar_position:1,description:"Devices are detected during the boot process and then periodically after startup."},a="Hardware Interaction",c={unversionedId:"specs/kernel/hardware",id:"specs/kernel/hardware",title:"Hardware Interaction",description:"Devices are detected during the boot process and then periodically after startup.",source:"@site/docs/specs/kernel/hardware.md",sourceDirName:"specs/kernel",slug:"/specs/kernel/hardware",permalink:"/docs/specs/kernel/hardware",draft:!1,editUrl:"https://github.com/violet-eco/docs/tree/main/docs/docs/specs/kernel/hardware.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{slug:"hardware",sidebar_position:1,description:"Devices are detected during the boot process and then periodically after startup."},sidebar:"violetSidebar",previous:{title:"Kernel",permalink:"/docs/specs/kernel/"},next:{title:"Kernel-Process Communication",permalink:"/docs/specs/kernel/kpc"}},s={},l=[{value:"Hardware Detection",id:"hardware-detection",level:2},{value:"Supported Connection Protocols",id:"supported-connection-protocols",level:3},{value:"Device Structure",id:"device-structure",level:2}],d={toc:l},p="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"hardware-interaction"},"Hardware Interaction"),(0,o.kt)("h2",{id:"hardware-detection"},"Hardware Detection"),(0,o.kt)("p",null,"Sakura detects devices throughout the boot process and periodically after starting.\nHardware detection is essential for initializing hardware components, installing\nnecessary drivers and allowing the system to communicate with associated drivers.\nAfter the system has begun, this detecting mechanism enables the hotplugging of\nnew devices."),(0,o.kt)("h3",{id:"supported-connection-protocols"},"Supported Connection Protocols"),(0,o.kt)("p",null,"The device detection techniques differ based on the device's connection protocol.\nConnection protocols that are supported include:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"PCIe:")," PCIe (Peripheral Component Interconnect Express) is a serial interface used to connect various components like graphic cards, network cards and storage devices."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"USB:")," USB (Universal Serial Bus) is a standard for connecting various devices like keyboards, mice, printers and storage devices. It allows for plug-and-play functionality."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"SATA:")," SATA (Serial AT Attachment) provides a standard and widely supported connection for storage devices.")),(0,o.kt)("h2",{id:"device-structure"},"Device Structure"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="Device Structure"',title:'"Device','Structure"':!0},"/// Represents information related to the power state and power management of a device.\nstruct PowerInfo {\n    /// Representing the current power state of the device.\n    pub power_state: u8,\n\n    /// Indicating whether the device is capable of waking up from a suspended state.\n    pub can_wakeup: bool,\n\n    /// Indicating whether the current device is currently in a suspended state.\n    pub is_suspended: bool,\n\n    /// A boolean indicating whether the device should trigger a wakeup event.\n    pub should_wakeup: bool,\n}\n\n/// Represents different types of buses to which a device can be connected.\nenum BusType {\n    Unknown,\n    PCI,\n    USB,\n    SATA,\n}\n\n/// Represents different physical locations where a device's connection point (ports, connectors, etc.)\n/// can be found on the device.\nenum DevicePhysicalLocationPanel {\n    Unknown,\n    Top,\n    Bottom,\n    Left,\n    Right,\n    Front,\n    Back,\n}\n\n/// Represents device data related to the physical location of a device's\n/// connection point.\nstruct DevicePhysicalLocation {\n    /// Physical location panel.\n    pub panel: DevicePhysicalLocationPanel,\n\n    /// Indicating whether the device is on the lid on a laptop system\n    pub lid: bool,\n}\n\nstruct Device {\n    /// Name of the device.\n    pub name: String,\n\n    /// Represents the parent device to which this device is attached.\n    /// If `Some`, it indicates that this device is a child device of the parent;\n    /// if `None`, it means the device is a top-level device.\n    pub parent: Box<Option<Device>>,\n\n    /// Represents informtion related to the power state and management of the device.\n    pub power: PowerInfo,\n\n    /// Represents the type of bus to which the device is connected.\n    pub bus: BusType,\n\n    /// Represents data related to the physical location of a device's connection point.\n    pub physical_location: DevicePhysicalLocation,\n}\n")))}u.isMDXComponent=!0}}]);