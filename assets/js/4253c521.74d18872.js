"use strict";(self.webpackChunkviolet_eco_github_io=self.webpackChunkviolet_eco_github_io||[]).push([[2454],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(t),g=a,h=d["".concat(l,".").concat(g)]||d[g]||u[g]||s;return t?r.createElement(h,i(i({ref:n},p),{},{components:t})):r.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,i=new Array(s);i[0]=g;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[d]="string"==typeof e?e:a,i[1]=o;for(var c=2;c<s;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},2412:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=t(7462),a=(t(7294),t(3905));const s={slug:"signals",sidebar_position:4,description:"Signals are a type of KPC. They are used by Nova to send information."},i="Signals",o={unversionedId:"specs/kernel/signals",id:"specs/kernel/signals",title:"Signals",description:"Signals are a type of KPC. They are used by Nova to send information.",source:"@site/docs/specs/kernel/signals.md",sourceDirName:"specs/kernel",slug:"/specs/kernel/signals",permalink:"/docs/specs/kernel/signals",draft:!1,editUrl:"https://github.com/violet-eco/docs/tree/main/docs/docs/specs/kernel/signals.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{slug:"signals",sidebar_position:4,description:"Signals are a type of KPC. They are used by Nova to send information."},sidebar:"violetSidebar",previous:{title:"System Calls",permalink:"/docs/specs/kernel/syscalls"},next:{title:"System services",permalink:"/docs/specs/services/"}},l={},c=[{value:"Signal Components",id:"signal-components",level:2},{value:"Signal Handling Process",id:"signal-handling-process",level:2},{value:"List of Signals",id:"list-of-signals",level:2}],p={toc:c},d="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"signals"},"Signals"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Signals")," are a type of ",(0,a.kt)("a",{parentName:"p",href:"/docs/specs/kernel/kpc"},"KPC"),".\nThey are used by Nova to send information."),(0,a.kt)("h2",{id:"signal-components"},"Signal Components"),(0,a.kt)("p",null,"When a process is created, Nova associates several components with it to facilitate\nsignal handling:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Signal Handler Table (SHT): The SHT is a data structure that stores the handlers for different signals."),(0,a.kt)("li",{parentName:"ul"},"Signals Queue: The signals queue serves as a buffer to hold signals sent to a process."),(0,a.kt)("li",{parentName:"ul"},"Readiness Indicator: The readiness indicator is a flag that indicates whether a process is ready to handle signals.")),(0,a.kt)("h2",{id:"signal-handling-process"},"Signal Handling Process"),(0,a.kt)("p",null,"When Nova provides a signal to a process, it follows a well-defined procedure to\nappropriately handle the signal:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Check for Active Handler:")," Nova first checks if the process has an active handler running. If a handler is running, the signal is placed in the signals queue."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Check Readiness Indicator:")," Nova checks the readiness indicator if the process's handler is not currently running. If the indicator is not set, the signal is queued until the process is ready."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Handler Lookup:")," Nova searches up the SHT to find the relevant signal handler. If the handler cannot be found, Nova may opt to ignore the signal or perform a default action, depending on the kind of signal."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Memory Area Validation:")," Nova checks if the memory region indicated by the handler's address may be executed by the current process. If not, the signal is changed to the ",(0,a.kt)("inlineCode",{parentName:"li"},"HANDLER_FAULT")," signal, which indicates a signal handling error."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Process Switch and Execution:")," Nova shifts the process to its main thread and intructs it to jump to the location of the signal's handler, so initiating the signal handling process. The handler's execution continues until it is finished."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Response Handling:")," If the signal is waiting for a response when the handler returns, Nova retrieves the response from a predefined register and takes necessary action according on the response. If no response is expected, Nova just makes the process to return to the address it was at prior to the signal's delivery, thereby continuing the original execution thread.")),(0,a.kt)("h2",{id:"list-of-signals"},"List of Signals"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"TODO")))}u.isMDXComponent=!0}}]);